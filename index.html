<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
    <title>PARTY GAMES - FINAL</title>
    
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        body { font-family: 'Pretendard', sans-serif; background-color: #0f172a; color: #f8fafc; -webkit-tap-highlight-color: transparent; overflow: hidden; height: 100dvh; display: flex; flex-direction: column; }
        #root { height: 100%; display: flex; flex-direction: column; }
        .spy-bg { background: radial-gradient(circle at 50% 0%, #1e1b4b 0%, #0f172a 60%, #020617 100%); flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .glass-card { background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4); }
        .modal-enter { animation: modalPop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
        @keyframes modalPop { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .toast-enter { animation: toastSlide 0.3s ease-out forwards; }
        @keyframes toastSlide { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .progress-bar { transition: width 1s linear; }
        .chat-scroll::-webkit-scrollbar { width: 4px; }
        .chat-scroll::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
        .chat-scroll::-webkit-scrollbar-track { background: transparent; }
        .loc-scroll::-webkit-scrollbar { width: 0px; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #3b82f6; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .card-pop:active { transform: scale(0.95); }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef, useLayoutEffect } = React;

        const firebaseConfig = {
            apiKey: "AIzaSyDvtMrhYYEqpJEjwhBzEiyKgBhmcoLKROM", 
            authDomain: "spyfall-b107.firebaseapp.com",
            databaseURL: "https://spyfall-b107-default-rtdb.firebaseio.com",
            projectId: "spyfall-b107",
            storageBucket: "spyfall-b107.firebasestorage.app",
            messagingSenderId: "35799604494",
            appId: "1:35799604494:web:9558db68aa6c5347d60b5f",
            measurementId: "G-HYQR22H174"
        };

        let isFirebaseConfigured = false;
        if (firebaseConfig.apiKey) {
            if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
            isFirebaseConfigured = true;
        }
        const database = isFirebaseConfigured ? firebase.database() : null;

        const SPYFALL_DATA = {
            hospital: { place: "ğŸ¥ ì¢…í•©ë³‘ì›", roles: ["ì™¸ê³¼ ì˜ì‚¬", "ê°„í˜¸ì‚¬", "í™˜ì", "ë³‘ì›ì¥", "êµ¬ê¸‰ëŒ€ì›", "ì•½ì‚¬", "ì²­ì†Œë¶€", "ë³´í˜¸ì"] },
            school: { place: "ğŸ« ê³ ë“±í•™êµ", roles: ["ë‹´ì„ êµì‚¬", "ì „êµ íšŒì¥", "ì²´ìœ¡ êµì‚¬", "êµì¥", "ë§¤ì  ì´ëª¨", "ì ìëŠ” í•™ìƒ", "ì „í•™ìƒ", "ì–‘í˜¸ êµì‚¬"] },
            airplane: { place: "âœˆï¸ ë¹„í–‰ê¸°", roles: ["ê¸°ì¥", "ìŠ¹ë¬´ì›", "ì¼ë“±ì„ ìŠ¹ê°", "ì•„ê¸°", "ìš”ë¦¬ì‚¬", "ë³´ì•ˆê´€", "ì •ë¹„ì‚¬", "ë¶€ê¸°ì¥"] },
            pirate: { place: "ğŸ´â€â˜ ï¸ í•´ì ì„ ", roles: ["ì„ ì¥", "ì„ ì›", "í¬ë¡œ", "ìš”ë¦¬ì‚¬", "ì¡°íƒ€ìˆ˜", "ê°‘íŒì¥", "ì•µë¬´ìƒˆ", "ë§ì›ê²½ ì„ ì›"] },
            movie: { place: "ğŸ¬ ì˜í™” ì´¬ì˜ì¥", roles: ["ê°ë…", "ì£¼ì—° ë°°ìš°", "ìŠ¤í„´íŠ¸ë§¨", "ì¹´ë©”ë¼", "ë¶„ì¥ì‚¬", "ì—‘ìŠ¤íŠ¸ë¼", "ì‘ê°€", "ì¡°ëª…"] },
            casino: { place: "ğŸ° ì¹´ì§€ë…¸", roles: ["ë”œëŸ¬", "ë¶€ì ì†ë‹˜", "ë³´ì•ˆ ìš”ì›", "ë§¤ë‹ˆì €", "ëˆ ìƒì€ ì‚¬ëŒ", "ë°”í…ë”", "íƒ€ì§œ", "ì²­ì†Œë¶€"] },
            space: { place: "ğŸš€ ìš°ì£¼ ì •ê±°ì¥", roles: ["ìš°ì£¼ì¸", "í•¨ì¥", "ì™¸ê³„ì¸", "ì—”ì§€ë‹ˆì–´", "ê´€ê´‘ê°", "AI ë¡œë´‡", "ì˜ë¬´ê´€", "í†µì‹  ì¥êµ"] },
            army: { place: "â›º êµ°ë¶€ëŒ€", roles: ["ì§€íœ˜ê´€", "ì‹ ë³‘", "ì·¨ì‚¬ë³‘", "ì¡°êµ", "ì˜ë¬´ë³‘", "íƒˆì˜ë³‘", "í–‰ë³´ê´€", "êµê´€"] },
            opera: { place: "ğŸ­ ì˜¤í˜ë¼ í•˜ìš°ìŠ¤", roles: ["ê°€ìˆ˜", "ì§€íœ˜ì", "ì—°ì£¼ì", "VIP", "ê°ë…", "ì•ˆë‚´ì›", "ë§¤í‘œì†Œ", "ì¡°ëª…"] },
            camping: { place: "â›º ìº í•‘ì¥", roles: ["ì•„ë¹ ", "ì•„ì´", "ì£¼ì¸", "ëŒ€í•™ìƒ", "ê¸°íƒ€ë§¨", "ëª¨ê¸° ë¬¼ë¦° ì‚¬ëŒ", "ì¥ì‘ë§¨", "ì»¤í”Œ"] },
            cruise: { place: "ğŸš¢ í¬ë£¨ì¦ˆ", roles: ["ì„ ì¥", "ë°”í…ë”", "ë§ˆìˆ ì‚¬", "ì‹ í˜¼ë¶€ë¶€", "ê°‘ë¶€", "ì•ˆì „ìš”ì›", "ë”œëŸ¬", "ì²­ì†Œë¶€"] },
            bank: { place: "ğŸ¦ ì€í–‰", roles: ["ê°•ë„", "ì§€ì ì¥", "ì§ì›", "ëŒ€ì¶œì", "ê²½ì°°", "ìˆ˜ë¦¬ê¸°ì‚¬", "ìˆ˜ì†¡ ìš”ì›", "VIP"] }
        };

        const LIAR_DATA = {
            food: { category: "ğŸ• ìŒì‹", words: ["ê¹€ì¹˜ì°Œê°œ", "ì¹˜í‚¨", "í”¼ì", "í–„ë²„ê±°", "ë¼ë©´", "ì´ˆë°¥", "ì‚¼ê²¹ì‚´", "ë–¡ë³¶ì´", "ì§œì¥ë©´", "ìŠ¤í…Œì´í¬"] },
            animal: { category: "ğŸ¦ ë™ë¬¼", words: ["ì‚¬ì", "í˜¸ë‘ì´", "ê³ ì–‘ì´", "ê°•ì•„ì§€", "ì½”ë¼ë¦¬", "ê¸°ë¦°", "íŒë‹¤", "ë…ìˆ˜ë¦¬", "ìƒì–´", "í­ê·„"] },
            job: { category: "ğŸ’¼ ì§ì—…", words: ["ì˜ì‚¬", "ë³€í˜¸ì‚¬", "ê²½ì°°", "ì†Œë°©ê´€", "ì„ ìƒë‹˜", "ê°œë°œì", "ìš”ë¦¬ì‚¬", "ê°€ìˆ˜", "ë°°ìš°", "ìš´ë™ì„ ìˆ˜"] },
            appliance: { category: "ğŸ“± ê°€ì „ì œí’ˆ", words: ["ëƒ‰ì¥ê³ ", "ì„¸íƒê¸°", "ì—ì–´ì»¨", "TV", "ì»´í“¨í„°", "ì²­ì†Œê¸°", "ì „ìë ˆì¸ì§€", "ë“œë¼ì´ê¸°", "ì„ í’ê¸°", "ìŠ¤í”¼ì»¤"] },
            sport: { category: "âš½ ìŠ¤í¬ì¸ ", words: ["ì¶•êµ¬", "ì•¼êµ¬", "ë†êµ¬", "ë°°êµ¬", "í…Œë‹ˆìŠ¤", "ìˆ˜ì˜", "ê³¨í”„", "íƒêµ¬", "ë°°ë“œë¯¼í„´", "ë³µì‹±"] },
            fruit: { category: "ğŸ ê³¼ì¼", words: ["ì‚¬ê³¼", "ë°”ë‚˜ë‚˜", "í¬ë„", "ë”¸ê¸°", "ìˆ˜ë°•", "ê·¤", "ë³µìˆ­ì•„", "íŒŒì¸ì• í”Œ", "ë©œë¡ ", "í‚¤ìœ„"] },
            place: { category: "ğŸï¸ ì¥ì†Œ", words: ["í•™êµ", "ë³‘ì›", "ë„ì„œê´€", "ê³µì›", "ì˜í™”ê´€", "ì¹´í˜", "ë°±í™”ì ", "ë†€ì´ê³µì›", "í•´ìˆ˜ìš•ì¥", "í¸ì˜ì "] },
            country: { category: "ğŸŒ ë‚˜ë¼", words: ["í•œêµ­", "ë¯¸êµ­", "ì¼ë³¸", "ì¤‘êµ­", "ì˜êµ­", "í”„ë‘ìŠ¤", "ë…ì¼", "ì´íƒˆë¦¬ì•„", "ë¸Œë¼ì§ˆ", "í˜¸ì£¼"] }
        };

        const generateRoomCode = () => Math.random().toString(36).substring(2, 6).toUpperCase();
        const generateUserId = () => 'user_' + Math.random().toString(36).substring(2, 15);
        
        const getRandomData = (mode) => {
            const data = mode === 'liar' ? LIAR_DATA : SPYFALL_DATA;
            const keys = Object.keys(data);
            const key = keys[Math.floor(Math.random() * keys.length)];
            return data[key];
        };

        const getUserColor = (uid) => {
            if (!uid) return '#9ca3af';
            const colors = ['#ef4444', '#f97316', '#f59e0b', '#84cc16', '#10b981', '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef', '#f43f5e'];
            let hash = 0;
            for (let i = 0; i < uid.length; i++) hash = uid.charCodeAt(i) + ((hash << 5) - hash);
            return colors[Math.abs(hash) % colors.length];
        };

        const TimerBar = ({ startTime, duration, onExpire, label, colorClass, showControl, onReduce }) => {
            const [timeLeft, setTimeLeft] = useState(duration);
            const [progress, setProgress] = useState(100);
            useEffect(() => {
                const interval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const remaining = Math.max(0, duration - elapsed);
                    setTimeLeft(remaining);
                    setProgress((remaining / duration) * 100);
                    if (remaining <= 0) { clearInterval(interval); if (onExpire) onExpire(); }
                }, 100);
                return () => clearInterval(interval);
            }, [startTime, duration]);
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            return (
                <div className="w-full mb-3">
                    <div className="flex justify-between items-center text-[10px] font-bold text-gray-400 mb-1.5 uppercase tracking-wider">
                        <span className="flex items-center gap-2">{label} {showControl && <button onClick={onReduce} className="bg-red-500/20 hover:bg-red-500/40 text-red-400 px-1.5 py-0.5 rounded border border-red-500/30 transition-colors">-1ë¶„</button>}</span>
                        <span className={timeLeft < 10000 ? "text-red-500 animate-pulse font-black" : "text-white"}>{minutes}:{seconds.toString().padStart(2, '0')}</span>
                    </div>
                    <div className="h-2 w-full bg-gray-700/50 rounded-full overflow-hidden"><div className={`h-full progress-bar ${colorClass}`} style={{ width: `${progress}%` }}></div></div>
                </div>
            );
        };

        const ChatArea = ({ messages, chatInput, setChatInput, sendMessage, myNickname, placeholderText }) => {
            const chatEndRef = useRef(null);
            useLayoutEffect(() => { chatEndRef.current?.scrollIntoView({ behavior: "auto" }); }, []);
            useEffect(() => { chatEndRef.current?.scrollIntoView({ behavior: "smooth" }); }, [messages.length]);

            return (
                <div className="flex flex-col flex-1 h-full min-h-0 bg-black/30 rounded-2xl border border-white/10 overflow-hidden shadow-inner relative">
                    <div className="bg-white/5 p-2 px-3 border-b border-white/10 text-[10px] font-bold text-gray-400 uppercase flex items-center gap-2 shrink-0">
                        <i data-lucide="message-square" className="w-3 h-3"></i> LIVE CHAT
                    </div>
                    <div className="flex-1 overflow-y-auto p-3 space-y-1 chat-scroll w-full">
                        {messages.length === 0 && <div className="text-white/20 text-center text-xs py-8">ëŒ€í™” ì‹œì‘...</div>}
                        {messages.map((msg, i) => {
                            if (msg.type === 'system') return <div key={i} className="flex justify-center my-2"><span className="text-[10px] text-white/40 bg-white/5 px-2 py-0.5 rounded-full border border-white/5">{msg.text}</span></div>;
                            const isMe = msg.sender === myNickname;
                            const prevMsg = messages[i - 1];
                            const isSameSender = prevMsg && prevMsg.sender === msg.sender && prevMsg.type === msg.type && prevMsg.type !== 'system';
                            return (
                                <div key={i} className={`flex flex-col ${isMe ? 'items-end' : 'items-start'} ${isSameSender ? 'mt-0.5' : 'mt-3'}`}>
                                    {!isSameSender && (
                                        <div className="flex items-center gap-1 mb-1 ml-1 mr-1">
                                            <span className="text-[10px] font-bold" style={{ color: getUserColor(msg.uid) }}>{msg.sender}</span>
                                            {msg.type === 'question' && <span className="text-[8px] bg-blue-500/20 text-blue-300 px-1 rounded border border-blue-500/30">ì§ˆë¬¸</span>}
                                            {msg.type === 'answer' && <span className="text-[8px] bg-orange-500/20 text-orange-300 px-1 rounded border border-orange-500/30">ë‹µë³€</span>}
                                        </div>
                                    )}
                                    <div className={`px-3 py-2 rounded-2xl text-sm max-w-[90%] break-words shadow-sm leading-relaxed border ${isMe ? 'bg-white/10 text-white border-white/10 rounded-tr-sm' : 'bg-black/40 text-gray-300 border-white/5 rounded-tl-sm'} ${msg.type === 'question' ? '!border-blue-500/50 !bg-blue-900/30' : ''} ${msg.type === 'answer' ? '!border-orange-500/50 !bg-orange-900/30' : ''}`}>{msg.text}</div>
                                </div>
                            );
                        })}
                        <div ref={chatEndRef} />
                    </div>
                    <form onSubmit={sendMessage} className="p-2 bg-black/40 border-t border-white/10 flex gap-2 shrink-0">
                        <input value={chatInput} onChange={e => setChatInput(e.target.value)} className="flex-1 bg-white/5 rounded-xl px-3 py-2 text-sm text-white focus:outline-none focus:ring-1 focus:ring-blue-500/50 transition-all placeholder-gray-600" placeholder={placeholderText} />
                        <button type="submit" className="bg-blue-600 hover:bg-blue-500 p-2 rounded-xl transition-colors shadow-lg" disabled={!chatInput.trim()}><i data-lucide="send" className="w-4 h-4 text-white"></i></button>
                    </form>
                </div>
            );
        };

        const CheatSheetModal = ({ onClose, mode }) => {
            const data = mode === 'liar' ? LIAR_DATA : SPYFALL_DATA;
            const title = mode === 'liar' ? 'ì£¼ì œë³„ ì œì‹œì–´' : 'ì¥ì†Œ ëª©ë¡';
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/90 p-4 modal-enter" onClick={onClose}>
                    <div className="glass-card w-full max-w-3xl max-h-[85vh] overflow-y-auto rounded-2xl p-5" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-xl font-black text-yellow-400">ğŸ—ºï¸ {title}</h2>
                            <button onClick={onClose} className="bg-white/10 p-2 rounded-full"><i data-lucide="x" className="w-5 h-5"></i></button>
                        </div>
                        <div className="grid grid-cols-2 gap-2">
                            {Object.values(data).map((item, i) => (
                                <div key={i} className="bg-white/5 p-3 rounded-xl border border-white/5">
                                    <div className="font-bold text-sm mb-1 text-gray-200">{mode === 'liar' ? item.category : item.place}</div>
                                    <div className="text-[10px] text-gray-500 truncate">{mode === 'liar' ? item.words.slice(0, 4).join(', ') + "..." : item.roles.slice(0, 3).join(', ') + "..."}</div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const SideCheatSheet = ({ isLeft, mode }) => {
            const data = Object.values(mode === 'liar' ? LIAR_DATA : SPYFALL_DATA);
            const mid = Math.ceil(data.length / 2);
            const displayData = isLeft ? data.slice(0, mid) : data.slice(mid);
            const label = mode === 'liar' ? 'Category' : 'Location';
            return (
                <div className={`hidden md:flex flex-col w-64 h-full p-2 overflow-y-auto loc-scroll gap-2 ${isLeft ? 'pr-1' : 'pl-1'}`}>
                    <div className="text-center text-xs font-bold text-gray-500 uppercase mb-2">{label} List {isLeft ? '1' : '2'}</div>
                    {displayData.map((item, i) => (
                        <div key={i} className="bg-white/5 p-3 rounded-xl border border-white/5 hover:bg-white/10 transition-colors">
                            <div className="font-bold text-sm mb-1 text-gray-200">{mode === 'liar' ? item.category : item.place}</div>
                            <div className="text-[10px] text-gray-500 truncate">{mode === 'liar' ? item.words.slice(0, 4).join(', ') + "..." : item.roles.slice(0, 3).join(', ') + "..."}</div>
                        </div>
                    ))}
                </div>
            );
        };

        const PlayerSelectionModal = ({ players, onSelect }) => (
            <div className="fixed inset-0 z-[70] flex flex-col items-center justify-center bg-black/95 p-6 modal-enter">
                <h2 className="text-2xl font-black text-blue-400 mb-2 text-center animate-bounce">ğŸ‘‰ ì§ˆë¬¸ ëŒ€ìƒ ì„ íƒ</h2>
                <div className="grid grid-cols-2 gap-3 w-full max-w-md">
                    {players.map(p => (
                        <button key={p.uid} onClick={() => onSelect(p.uid)} className="bg-gray-800 border border-gray-600 hover:border-blue-500 hover:bg-gray-700 p-4 rounded-2xl flex flex-col items-center gap-2 transition-all card-pop">
                            <div className="w-10 h-10 rounded-full flex items-center justify-center text-lg font-bold bg-gray-900" style={{color: getUserColor(p.uid)}}>{p.name.substring(0,1)}</div>
                            <span className="font-bold text-white text-sm">{p.name}</span>
                        </button>
                    ))}
                </div>
            </div>
        );

        const VoteModal = ({ players, votes, myVote, onVote, onClose, mode }) => {
            const voteCounts = {};
            const villainName = mode === 'liar' ? 'ë¼ì´ì–´' : 'ìŠ¤íŒŒì´';
            Object.values(votes || {}).forEach(targetId => { voteCounts[targetId] = (voteCounts[targetId] || 0) + 1; });
            return (
                <div className="fixed inset-0 z-[80] flex items-center justify-center bg-red-900/90 p-4 modal-enter">
                    <div className="glass-card w-full max-w-md rounded-2xl p-6 border-red-500/30">
                        <h2 className="text-xl font-black text-red-400 mb-1 text-center">ğŸš¨ {villainName} ì§€ëª© íˆ¬í‘œ</h2>
                        <div className="space-y-2 mb-4 max-h-[50vh] overflow-y-auto">
                            {players.map(p => {
                                const count = voteCounts[p.uid] || 0;
                                const isSelected = myVote === p.uid;
                                return (
                                    <button key={p.uid} onClick={() => onVote(p.uid)} className={`w-full flex justify-between items-center p-3 rounded-xl border transition-all ${isSelected ? 'bg-red-600 border-red-400' : 'bg-black/40 border-white/5'}`}>
                                        <span className="font-bold text-sm">{p.name}</span>
                                        <div className="flex items-center gap-2">
                                            {count > 0 && <span className="text-xs bg-white/20 px-2 py-0.5 rounded">{count}í‘œ</span>}
                                            {isSelected && <i data-lucide="check-circle" className="w-4 h-4"></i>}
                                        </div>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const AnswerConfirmModal = ({ text, onConfirm, onCancel }) => (
            <div className="fixed inset-0 z-[90] flex items-center justify-center bg-black/90 p-6 modal-enter">
                <div className="glass-card w-full max-w-sm rounded-3xl p-6 text-center border-2 border-orange-500">
                    <h2 className="text-xl font-black text-white mb-2">ğŸ’¬ ë‹µë³€ í™•ì¸</h2>
                    <p className="text-xs text-gray-400 mb-4">ì´ ë‚´ìš©ìœ¼ë¡œ ë‹µë³€í•˜ê³  í„´ì„ ë„˜ê¸°ì‹œê² ìŠµë‹ˆê¹Œ?</p>
                    <div className="bg-white/10 p-4 rounded-xl text-white font-bold text-lg mb-6 break-words">"{text}"</div>
                    <div className="flex gap-2">
                        <button onClick={onCancel} className="flex-1 bg-gray-600 py-3 rounded-xl font-bold">ìˆ˜ì •</button>
                        <button onClick={onConfirm} className="flex-1 bg-orange-600 hover:bg-orange-500 py-3 rounded-xl font-bold">ì „ì†¡</button>
                    </div>
                </div>
            </div>
        );

        const Toast = ({ message }) => (
            <div className="fixed top-20 left-1/2 transform -translate-x-1/2 bg-white/90 text-black px-6 py-3 rounded-full font-bold shadow-2xl z-[100] toast-enter flex items-center gap-2">
                <i data-lucide="check" className="w-5 h-5 text-green-600"></i> {message}
            </div>
        );

        const RuleModal = ({ onClose, mode }) => {
            const isLiar = mode === 'liar';
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/95 p-4 modal-enter" onClick={onClose}>
                    <div className="glass-card w-full max-w-lg max-h-[90vh] overflow-y-auto rounded-3xl p-6 relative border-2 border-yellow-500/30" onClick={e => e.stopPropagation()}>
                        <div className="absolute top-4 right-4"><button onClick={onClose} className="bg-white/10 p-2 rounded-full"><i data-lucide="x" className="w-5 h-5"></i></button></div>
                        <h2 className="text-3xl font-black text-yellow-400 mb-6 text-center">ğŸ“œ {isLiar ? 'ë¼ì´ì–´ ê²Œì„' : 'ìŠ¤íŒŒì´í´'} ê·œì¹™</h2>
                        <div className="space-y-6">
                            <div className="bg-white/5 p-4 rounded-2xl border border-white/10">
                                <h3 className="text-lg font-bold text-blue-300 mb-2">ğŸ‘® ì‹œë¯¼ì˜ ëª©í‘œ</h3>
                                <p className="text-sm text-gray-300 leading-relaxed">{isLiar ? "ëª¨ë‘ê°€ ê°™ì€ 'ì œì‹œì–´'ë¥¼ ë°›ìŠµë‹ˆë‹¤. ì œì‹œì–´ê°€ ë¬´ì—‡ì¸ì§€ ëª¨ë¥´ëŠ” 'ë¼ì´ì–´'ë¥¼ ì°¾ì•„ë‚´ì„¸ìš”!" : "ëª¨ë‘ê°€ ê°™ì€ 'ì¥ì†Œ'ì— ìˆìŠµë‹ˆë‹¤. ì¥ì†Œë¥¼ ëª¨ë¥´ëŠ” 'ìŠ¤íŒŒì´'ë¥¼ ì°¾ì•„ë‚´ì„¸ìš”!"}</p>
                            </div>
                            <div className="bg-white/5 p-4 rounded-2xl border border-white/10">
                                <h3 className="text-lg font-bold text-red-400 mb-2">ğŸ˜ˆ {isLiar ? 'ë¼ì´ì–´' : 'ìŠ¤íŒŒì´'}ì˜ ëª©í‘œ</h3>
                                <p className="text-sm text-gray-300 leading-relaxed">{isLiar ? "ë‹¹ì‹ ì€ ì œì‹œì–´ë¥¼ ëª¨ë¦…ë‹ˆë‹¤. ì‹œë¯¼ë“¤ì˜ ëŒ€í™”ë¥¼ ë“£ê³  ëˆˆì¹˜ê» ì œì‹œì–´ë¥¼ ìœ ì¶”í•˜ì—¬ ë“¤í‚¤ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤." : "ë‹¹ì‹ ì€ ì¥ì†Œë¥¼ ëª¨ë¦…ë‹ˆë‹¤. ì‹œë¯¼ë“¤ì˜ ëŒ€í™”ë¥¼ ë“£ê³  ëˆˆì¹˜ê» ì¥ì†Œë¥¼ ìœ ì¶”í•´ì•¼ í•©ë‹ˆë‹¤."}</p>
                            </div>
                        </div>
                        <button onClick={onClose} className="w-full bg-yellow-500 hover:bg-yellow-600 text-black font-bold py-4 rounded-xl mt-6 shadow-lg">í™•ì¸</button>
                    </div>
                </div>
            );
        };

        class ErrorBoundary extends React.Component {
            constructor(props) { super(props); this.state = { hasError: false }; }
            static getDerivedStateFromError(error) { return { hasError: true }; }
            componentDidCatch(error) { console.error("Crash:", error); }
            render() {
                if (this.state.hasError) {
                    return <div className="spy-bg flex items-center justify-center p-6 text-center"><div className="glass-card p-6 rounded-xl"><h1 className="text-red-500 font-bold mb-2">ì˜¤ë¥˜ ë°œìƒ</h1><button onClick={() => { localStorage.clear(); window.location.reload(); }} className="bg-white/10 px-4 py-2 rounded-lg">ë°ì´í„° ì´ˆê¸°í™” ë° ìƒˆë¡œê³ ì¹¨</button></div></div>;
                }
                return this.props.children;
            }
        }

        function App() {
            const [userId] = useState(() => {
                const stored = localStorage.getItem('spyfall_user_id');
                if (stored) return stored;
                const newId = generateUserId();
                localStorage.setItem('spyfall_user_id', newId);
                return newId;
            });

            const [view, setView] = useState('lobby'); 
            const [roomId, setRoomId] = useState(''); 
            const [inputRoomId, setInputRoomId] = useState(''); 
            const [nickname, setNickname] = useState(localStorage.getItem('spyfall_nickname') || '');
            const [roomData, setRoomData] = useState(null);
            const [messages, setMessages] = useState([]);
            const [chatInput, setChatInput] = useState('');
            const [showRoleModal, setShowRoleModal] = useState(false);
            const [showResultModal, setShowResultModal] = useState(false);
            const [showLocationModal, setShowLocationModal] = useState(false);
            const [showRuleModal, setShowRuleModal] = useState(false);
            const [turnNotification, setTurnNotification] = useState(null);
            const [pendingAnswer, setPendingAnswer] = useState(null);
            const [gameTimeOpt, setGameTimeOpt] = useState(8);
            const [turnTimeOpt, setTurnTimeOpt] = useState(40);
            const [maxPlayersOpt, setMaxPlayersOpt] = useState(12);
            const [roundsOpt, setRoundsOpt] = useState(3);
            const [gameMode, setGameMode] = useState('spyfall'); 
            const [showToast, setShowToast] = useState(false); 
            const lastTurnTimeRef = useRef(0);

            useEffect(() => { if (nickname) localStorage.setItem('spyfall_nickname', nickname); }, [nickname]);
            useEffect(() => { if (window.lucide) window.lucide.createIcons(); }, [view, showRoleModal, showResultModal, roomData, showToast, showRuleModal, gameMode, pendingAnswer]);

            useEffect(() => {
                if (roomData?.settings) {
                    setGameTimeOpt(roomData.settings.gameDuration / 60000);
                    setTurnTimeOpt(roomData.settings.turnDuration / 1000);
                    if(roomData.settings.maxPlayers) setMaxPlayersOpt(roomData.settings.maxPlayers);
                    if(roomData.settings.gameMode) setGameMode(roomData.settings.gameMode);
                    if(roomData.settings.rounds) setRoundsOpt(roomData.settings.rounds);
                }
            }, [roomData?.settings]);

            // ğŸ”¥ ì‹œê°„ ë‹¨ì¶• íˆ¬í‘œ ì²´í¬ (ê³¼ë°˜ìˆ˜ í™•ì¸)
            useEffect(() => {
                if (roomData?.gameState?.timeVotes && roomData.status === 'playing') {
                    const players = Object.keys(roomData.players);
                    const voteCount = Object.keys(roomData.gameState.timeVotes).length;
                    
                    // ê³¼ë°˜ìˆ˜ ì´ìƒì´ë©´ íˆ¬í‘œ í˜ì´ì¦ˆë¡œ ë°”ë¡œ ì´ë™
                    if (voteCount >= Math.ceil(players.length / 2)) {
                        startVotingPhase();
                    }
                }
            }, [roomData?.gameState?.timeVotes]);

            useEffect(() => {
                if (roomData?.votes && roomData?.status === 'voting') {
                    const players = Object.keys(roomData.players);
                    const votes = Object.values(roomData.votes);
                    if (votes.length >= players.length) {
                        const voteCounts = {};
                        votes.forEach(v => voteCounts[v] = (voteCounts[v] || 0) + 1);
                        let maxVotes = 0;
                        let elected = null;
                        Object.entries(voteCounts).forEach(([uid, count]) => { if (count > maxVotes) { maxVotes = count; elected = uid; } });
                        handleEndGame(`íˆ¬í‘œ ê²°ê³¼, ${roomData.players[elected].name}ë‹˜ì´ ì§€ëª©ë˜ì—ˆìŠµë‹ˆë‹¤!`);
                    }
                }
            }, [roomData?.votes]);

            useEffect(() => {
                if (roomData?.status === 'playing') {
                    if (!showRoleModal && view !== 'game') setShowRoleModal(true);
                    setShowResultModal(false);
                } else if (roomData?.status === 'finished') {
                    setShowResultModal(true);
                    setShowRoleModal(false);
                }
            }, [roomData?.status]);

            useEffect(() => {
                if (roomData?.status === 'playing' && roomData.gameState) {
                    const { turnStartTime, turnPlayer, targetPlayer } = roomData.gameState;
                    if (turnStartTime > lastTurnTimeRef.current) {
                        lastTurnTimeRef.current = turnStartTime;
                        if (gameMode === 'liar') {
                            if (turnPlayer === userId) {
                                setTurnNotification({ type: 'ask', title: 'ğŸ—£ï¸ ë°œì–¸ ì°¨ë¡€!', message: 'ì œì‹œì–´ì— ëŒ€í•´ ì„¤ëª…í•˜ì„¸ìš”.', color: 'bg-green-600 border-green-400' });
                            }
                        } else {
                            if (turnPlayer === userId && !targetPlayer) {
                                setTurnNotification({ type: 'ask', title: 'ğŸ—£ï¸ ì§ˆë¬¸ ì°¨ë¡€!', message: 'ì›í•˜ëŠ” ì‚¬ëŒì„ ì§€ëª©í•˜ì„¸ìš”.', color: 'bg-blue-600 border-blue-400' });
                            } else if (targetPlayer === userId) {
                                setTurnNotification({ type: 'answer', title: 'ğŸ’¬ ë‹µë³€ ì°¨ë¡€!', message: 'ì§ˆë¬¸ì— ëŒ€ë‹µí•˜ì„¸ìš”.', color: 'bg-orange-600 border-orange-400' });
                            }
                        }
                    }
                }
            }, [roomData, userId, gameMode]);

            useEffect(() => {
                if (!roomId || !database) return;
                const roomRef = database.ref('rooms/' + roomId);
                const chatRef = database.ref('rooms/' + roomId + '/messages');
                const roomListener = roomRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) setRoomData(data);
                    else { if(view !== 'lobby') { alert('ë°©ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.'); window.location.reload(); } }
                });
                const chatListener = chatRef.limitToLast(100).on('value', snap => {
                    const data = snap.val();
                    setMessages(data ? Object.values(data) : []);
                });
                database.ref('rooms/' + roomId + '/players/' + userId).onDisconnect().remove();
                return () => { roomRef.off('value', roomListener); chatRef.off('value', chatListener); };
            }, [roomId]);

            const leaveRoomCleanup = async () => {
                if (roomId && database) {
                    setRoomId(''); setRoomData(null); setMessages([]); setView('lobby');
                    try { 
                        await database.ref(`rooms/${roomId}/messages`).push({ sender: 'System', text: `${nickname} í‡´ì¥`, timestamp: Date.now(), type: 'system' }); 
                        const playerRef = database.ref('rooms/' + roomId + '/players/' + userId);
                        await playerRef.remove();
                        const roomRef = database.ref('rooms/' + roomId);
                        const snap = await roomRef.once('value');
                        if (snap.exists()) {
                            const data = snap.val();
                            if (!data.players || Object.keys(data.players).length === 0) await roomRef.remove();
                        }
                    } catch(e) {}
                }
            };

            const handleUpdateSettings = async (type, value) => {
                if (!roomId || roomData.hostId !== userId) return;
                const updates = {};
                if (type === 'game') updates['settings/gameDuration'] = value * 60 * 1000;
                if (type === 'turn') updates['settings/turnDuration'] = value * 1000;
                if (type === 'max') updates['settings/maxPlayers'] = Number(value);
                if (type === 'mode') updates['settings/gameMode'] = value; 
                if (type === 'rounds') updates['settings/rounds'] = Number(value);
                await database.ref(`rooms/${roomId}`).update(updates);
            };

            const handleCreateRoom = async () => {
                if (!nickname.trim()) return alert('ë‹‰ë„¤ì„ í•„ìˆ˜');
                const newId = generateRoomCode();
                await database.ref('rooms/' + newId).set({
                    hostId: userId,
                    players: { [userId]: { uid: userId, name: nickname, role: null, isSpy: false } },
                    status: 'waiting',
                    settings: { gameDuration: gameTimeOpt * 60 * 1000, turnDuration: turnTimeOpt * 1000, maxPlayers: 12, gameMode: 'spyfall', rounds: 3 },
                    votes: {}
                });
                setRoomId(newId); setInputRoomId(newId); setView('room');
            };

            const handleJoinRoom = async () => {
                if (!nickname.trim() || !inputRoomId.trim()) return alert('ì •ë³´ ì…ë ¥ í•„ìˆ˜');
                const targetId = inputRoomId.toUpperCase();
                const snap = await database.ref('rooms/' + targetId).once('value');
                if (!snap.exists()) return alert('ì—†ëŠ” ë°©ì…ë‹ˆë‹¤.');
                const data = snap.val();
                if (data.players) {
                    if (Object.keys(data.players).length >= (data.settings?.maxPlayers || 12)) return alert('ë°©ì´ ê½‰ ì°¼ìŠµë‹ˆë‹¤!');
                    const isDuplicate = Object.values(data.players).some(p => p.name === nickname.trim());
                    if (isDuplicate) return alert('ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤.');
                }
                await database.ref(`rooms/${targetId}/players/${userId}`).set({ uid: userId, name: nickname, role: null, isSpy: false });
                setRoomId(targetId); setView('room');
            };

            const handleStartGame = async () => {
                const players = Object.values(roomData.players || {});
                if (players.length < 3) return alert('ìµœì†Œ 3ëª… í•„ìš”');
                const mode = roomData.settings.gameMode;
                const dataItem = getRandomData(mode); 
                const isLiarMode = mode === 'liar';
                let roles = [];
                if (isLiarMode) {
                    const secretWord = dataItem.words[Math.floor(Math.random() * dataItem.words.length)];
                    roles = Array(players.length).fill(secretWord); 
                } else {
                    roles = [...dataItem.roles].sort(() => Math.random() - 0.5);
                }
                const spyIndex = Math.floor(Math.random() * players.length);
                const updatedPlayers = {};
                const playerIds = [];
                players.forEach((p, idx) => {
                    const isSpy = idx === spyIndex;
                    const role = isSpy ? (isLiarMode ? 'ë¼ì´ì–´' : 'SPY') : (isLiarMode ? roles[idx] : (roles.pop() || 'ì‹œë¯¼'));
                    updatedPlayers[p.uid] = { ...p, role, isSpy };
                    playerIds.push(p.uid);
                });
                if (isLiarMode) {
                    for (let i = playerIds.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [playerIds[i], playerIds[j]] = [playerIds[j], playerIds[i]];
                    }
                }
                const firstPlayerId = isLiarMode ? playerIds[0] : players[Math.floor(Math.random() * players.length)].uid;
                await database.ref('rooms/' + roomId).update({
                    status: 'playing', 
                    locationName: isLiarMode ? dataItem.category : dataItem.place, 
                    players: updatedPlayers, votes: {},
                    gameState: { gameStartTime: Date.now(), turnStartTime: Date.now(), turnPlayer: firstPlayerId, targetPlayer: null, turnOrder: playerIds, currentTurnIndex: 0, currentRound: 1, timeVotes: {} }
                });
                await database.ref(`rooms/${roomId}/messages`).push({ sender: 'System', text: `ê²Œì„ ì‹œì‘!`, timestamp: Date.now(), type: 'system' });
                lastTurnTimeRef.current = 0; 
            };

            const handleEndGame = async (reason = "") => { await database.ref('rooms/' + roomId).update({ status: 'finished', endReason: reason }); };
            
            const startVotingPhase = async () => {
                await database.ref('rooms/' + roomId).update({ status: 'voting', votes: {} });
                sendMessageLocal("ğŸš¨ íˆ¬í‘œê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤! ë²”ì¸ì„ ì§€ëª©í•˜ì„¸ìš”.", "system");
            };

            const handleRestart = async () => {
                const players = Object.values(roomData.players || {});
                const resetPlayers = {};
                players.forEach(p => resetPlayers[p.uid] = { ...p, role: null, isSpy: false });
                await database.ref('rooms/' + roomId).update({ status: 'waiting', locationName: null, players: resetPlayers, gameState: null, votes: {} });
            };

            const handleSelectPlayer = async (targetId) => {
                const { turnStartTime } = roomData.gameState;
                const hasAsked = messages.some(m => m.uid === userId && m.type === 'question' && m.timestamp > turnStartTime);
                if (!hasAsked) { alert("ğŸ—£ï¸ ë¨¼ì € ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”!"); return; }
                await database.ref(`rooms/${roomId}/gameState`).update({ targetPlayer: targetId, turnStartTime: Date.now() });
            };
            
            const handleVote = async (targetUid) => {
                if(!database) return;
                try { await database.ref(`rooms/${roomId}/votes/${userId}`).set(targetUid); } catch(e) { console.error(e); }
            };

            const handleReduceGameTime = async () => {
                const currentStart = roomData.gameState.gameStartTime;
                await database.ref(`rooms/${roomId}/gameState`).update({ gameStartTime: currentStart - 60000 });
                sendMessageLocal("â° ì‹œê°„ -1ë¶„", "system");
            };

            // ğŸ”¥ [ì‹ ê·œ] ì‹œê°„ ë‹¨ì¶• íˆ¬í‘œ í† ê¸€
            const handleTimeReductionToggle = async () => {
                const timeVotes = roomData.gameState.timeVotes || {};
                if (timeVotes[userId]) {
                    await database.ref(`rooms/${roomId}/gameState/timeVotes/${userId}`).remove();
                } else {
                    await database.ref(`rooms/${roomId}/gameState/timeVotes/${userId}`).set(true);
                }
            };

            const handleSkipTurn = async () => {
                if (gameMode === 'liar') {
                    handleLiarPassTurn();
                } else {
                    const { turnPlayer } = roomData.gameState;
                    const playerIds = Object.keys(roomData.players);
                    const candidates = playerIds.filter(id => id !== turnPlayer);
                    const randomTarget = candidates[Math.floor(Math.random() * candidates.length)];
                    await database.ref(`rooms/${roomId}/gameState`).update({ targetPlayer: null, turnPlayer: randomTarget, turnStartTime: Date.now() });
                    sendMessageLocal("â© í„´ ìŠ¤í‚µë¨", "system");
                }
            };

            const handleLiarPassTurn = async () => {
                const { turnOrder, currentTurnIndex, currentRound } = roomData.gameState;
                const maxRounds = roomData.settings.rounds || 3;
                let nextIndex = currentTurnIndex + 1;
                let nextRound = currentRound;
                if (nextIndex >= turnOrder.length) { nextIndex = 0; nextRound++; }
                if (nextRound > maxRounds) { startVotingPhase(); } 
                else {
                    const nextPlayer = turnOrder[nextIndex];
                    await database.ref(`rooms/${roomId}/gameState`).update({ turnPlayer: nextPlayer, currentTurnIndex: nextIndex, currentRound: nextRound, turnStartTime: Date.now() });
                }
            };

            const handleGameTimeExpire = () => { 
                if (roomData.hostId === userId) {
                    if (gameMode === 'spyfall') startVotingPhase();
                } 
            };
            const handleTurnTimeExpire = () => { if (roomData.hostId === userId) handleSkipTurn(); };
            const sendMessageLocal = (text, type='chat') => { database.ref(`rooms/${roomId}/messages`).push({ sender: nickname, uid: userId, text, timestamp: Date.now(), type }); };
            
            const sendMessage = async (e) => {
                e.preventDefault();
                if (!chatInput.trim()) return;
                
                let msgType = 'chat';
                if (roomData?.status === 'playing' && roomData.gameState) {
                    if(gameMode === 'spyfall') {
                        if (roomData.gameState.turnPlayer === userId && !roomData.gameState.targetPlayer) msgType = 'question';
                        else if (roomData.gameState.targetPlayer === userId) msgType = 'answer';
                    }
                }

                if (msgType === 'answer' && gameMode === 'spyfall') {
                    setPendingAnswer(chatInput);
                    return;
                }

                await database.ref(`rooms/${roomId}/messages`).push({ sender: nickname, uid: userId, text: chatInput, timestamp: Date.now(), type: msgType });
                setChatInput('');
            };

            const confirmAnswer = async () => {
                if (!pendingAnswer) return;
                await database.ref(`rooms/${roomId}/messages`).push({ sender: nickname, uid: userId, text: pendingAnswer, timestamp: Date.now(), type: 'answer' });
                await database.ref(`rooms/${roomId}/gameState`).update({ turnPlayer: userId, targetPlayer: null, turnStartTime: Date.now() });
                setChatInput('');
                setPendingAnswer(null);
            };

            const copyCode = async () => {
                if (navigator.clipboard) { await navigator.clipboard.writeText(roomId); setShowToast(true); setTimeout(() => setShowToast(false), 2000); } 
                else { prompt("ë°© ì½”ë“œ", roomId); }
            };

            if (!isFirebaseConfigured) return <div className="spy-bg flex items-center justify-center p-6 text-white font-bold">API KEY ì„¤ì • í•„ìš”</div>;

            if (view === 'lobby') {
                return (
                    <div className="spy-bg flex items-center justify-center p-4">
                        <div className="w-full max-w-sm glass-card p-6 rounded-3xl text-center shadow-2xl relative z-10">
                            <button onClick={() => setShowRuleModal(true)} className="absolute top-4 right-4 bg-white/10 p-2 rounded-full hover:bg-white/20 transition-colors"><i data-lucide="book-open" className="w-5 h-5 text-yellow-400"></i></button>
                            <div className="mb-6"><div className="text-5xl mb-2 animate-bounce">ğŸ•µï¸</div><h1 className="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-red-500 to-amber-500 tracking-tighter">PARTY GAMES</h1></div>
                            <div className="space-y-3">
                                <input value={nickname} onChange={e => setNickname(e.target.value)} placeholder="ë‹‰ë„¤ì„" className="w-full bg-black/40 border border-white/10 rounded-xl px-4 py-3 text-white text-center font-bold" />
                                <div className="pt-2 space-y-3">
                                    <button onClick={handleCreateRoom} className="w-full bg-red-600 hover:bg-red-500 text-white py-3 rounded-xl font-bold shadow-lg">ë°© ë§Œë“¤ê¸°</button>
                                    <div className="flex gap-2 h-14"><input value={inputRoomId} onChange={e => setInputRoomId(e.target.value.toUpperCase())} placeholder="ì½”ë“œ" className="w-24 bg-black/40 border border-white/10 rounded-xl px-2 text-center uppercase text-white font-black text-xl" />
                                    <button onClick={handleJoinRoom} className="flex-1 bg-blue-600 hover:bg-blue-500 text-white rounded-xl font-bold">ì°¸ê°€</button></div>
                                </div>
                            </div>
                        </div>
                        {showRuleModal && <RuleModal onClose={() => setShowRuleModal(false)} mode="spyfall" />}
                    </div>
                );
            }

            if (view === 'room' || view === 'game' || view === 'result') {
                if (!roomData) return <div className="spy-bg flex items-center justify-center flex-col"><div className="spinner mb-4"></div><div className="text-white font-bold animate-pulse">ë¡œë”© ì¤‘...</div></div>;
                
                const players = Object.values(roomData.players || {});
                const isHost = roomData.hostId === userId;
                const me = roomData.players[userId];
                const gameState = roomData.gameState;
                const isPlaying = roomData.status === 'playing';
                const isVoting = roomData.status === 'voting';
                const currentMode = roomData.settings.gameMode; 

                const isMyTurnToAsk = isPlaying && currentMode === 'spyfall' && gameState?.turnPlayer === userId && !gameState?.targetPlayer;
                const isMyTurnToAnswer = isPlaying && currentMode === 'spyfall' && gameState?.targetPlayer === userId;
                const isMyLiarTurn = isPlaying && currentMode === 'liar' && gameState?.turnPlayer === userId;

                let statusText = "ëŒ€ê¸° ì¤‘...";
                let placeholderText = "ëŒ€í™” ì°¸ì—¬...";

                if (isPlaying && gameState) {
                    if (currentMode === 'liar') {
                        const tp = roomData.players[gameState.turnPlayer];
                        statusText = `ğŸ—£ï¸ ${tp?.name}ë‹˜ ë°œì–¸ ì¤‘ (Round ${gameState.currentRound}/${roomData.settings.rounds})`;
                        placeholderText = isMyLiarTurn ? "ì œì‹œì–´ë¥¼ ì„¤ëª…í•˜ì„¸ìš”..." : "ë“£ëŠ” ì¤‘...";
                    } else {
                        if (!gameState.targetPlayer) {
                            const tp = roomData.players[gameState.turnPlayer];
                            statusText = `ğŸ—£ï¸ ${tp?.name}ë‹˜ ì§ˆë¬¸ ì¤‘`;
                            if (isMyTurnToAsk) {
                                 const hasAsked = messages.some(m => m.uid === userId && m.type === 'question' && m.timestamp > gameState.turnStartTime);
                                 placeholderText = hasAsked ? "ğŸ‘‰ ìƒëŒ€ë¥¼ ì§€ëª©í•˜ì„¸ìš”!" : "ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”";
                            } else placeholderText = "ì§ˆë¬¸ìê°€ ë°œì–¸ ì¤‘ì…ë‹ˆë‹¤";
                        } else {
                            const tp = roomData.players[gameState.targetPlayer];
                            statusText = `ğŸ’¬ ${tp?.name}ë‹˜ ë‹µë³€ ì¤‘`;
                            if (isMyTurnToAnswer) placeholderText = "ë‹µë³€ì„ ì…ë ¥í•˜ì„¸ìš”";
                            else placeholderText = "ë‹µë³€ìê°€ ë°œì–¸ ì¤‘ì…ë‹ˆë‹¤";
                        }
                    }
                } else if (isVoting) {
                    statusText = "ğŸš¨ íˆ¬í‘œ ì§„í–‰ ì¤‘...";
                }

                // ì‹œê°„ ë‹¨ì¶• íˆ¬í‘œ ì¹´ìš´íŠ¸ ê³„ì‚°
                const timeVotes = gameState?.timeVotes ? Object.keys(gameState.timeVotes).length : 0;
                const totalPlayers = players.length;
                const hasVotedTime = gameState?.timeVotes?.[userId];

                return (
                    <div className="spy-bg flex flex-row">
                        <SideCheatSheet isLeft={true} mode={currentMode} />
                        <div className="flex-1 flex flex-col h-full max-w-xl mx-auto p-3 relative overflow-hidden">
                            <div className="glass-card p-2 rounded-xl mb-2 flex justify-between items-center shrink-0">
                                <div><span className="text-[10px] text-gray-400 font-bold block">CODE</span><span className="text-lg font-black text-yellow-400 tracking-widest">{roomId}</span></div>
                                <div className="text-sm font-bold text-white/90 truncate max-w-[150px]">{statusText}</div>
                                <div className="flex gap-1">
                                    <button onClick={() => setShowLocationModal(true)} className="md:hidden bg-purple-500/20 text-purple-300 border border-purple-500/30 px-2 py-1 rounded text-xs font-bold">ì¡±ë³´</button>
                                    <button onClick={() => setShowRuleModal(true)} className="bg-yellow-500/10 text-yellow-300 border border-yellow-500/20 px-2 py-1 rounded text-xs font-bold">ë£°</button>
                                    <button onClick={copyCode} className="bg-white/10 px-3 py-1 rounded text-xs font-bold text-white border border-white/20 hover:bg-white/20 transition-colors">ë³µì‚¬</button>
                                    <button onClick={leaveRoomCleanup} className="bg-red-500/20 text-red-400 border border-red-500/20 px-2 py-1 rounded text-xs font-bold">ë‚˜ê°€ê¸°</button>
                                </div>
                            </div>

                            {!isPlaying && !isVoting && roomData.status === 'waiting' && (
                                <div className="glass-card p-4 rounded-xl mb-2 overflow-y-auto">
                                    <div className="flex justify-center mb-4">
                                        <div className="bg-black/30 p-1 rounded-lg flex gap-1 border border-white/10">
                                            <button onClick={() => isHost && handleUpdateSettings('mode', 'spyfall')} className={`px-4 py-2 rounded-md text-xs font-bold transition-all ${gameMode === 'spyfall' ? 'bg-blue-600 text-white shadow-lg' : 'text-gray-400 hover:text-white'}`} disabled={!isHost}>ğŸ•µï¸ ìŠ¤íŒŒì´í´</button>
                                            <button onClick={() => isHost && handleUpdateSettings('mode', 'liar')} className={`px-4 py-2 rounded-md text-xs font-bold transition-all ${gameMode === 'liar' ? 'bg-red-600 text-white shadow-lg' : 'text-gray-400 hover:text-white'}`} disabled={!isHost}>ğŸ¤¥ ë¼ì´ì–´ê²Œì„</button>
                                        </div>
                                    </div>

                                    <div className="flex gap-2 justify-center mb-4">
                                        {gameMode === 'spyfall' ? (
                                            <div className="flex flex-col"><span className="text-[10px] text-gray-400 font-bold mb-1">ê²Œì„ ì‹œê°„</span>
                                            <select disabled={!isHost} value={gameTimeOpt} onChange={e => handleUpdateSettings('game', e.target.value)} className="bg-black/30 border border-white/10 rounded px-2 py-1 text-white text-xs w-16">
                                                {[3,4,5,6,7,8,10,12,15].map(t => <option key={t} value={t}>{t}ë¶„</option>)}
                                            </select></div>
                                        ) : (
                                            <div className="flex flex-col"><span className="text-[10px] text-gray-400 font-bold mb-1">ë¼ìš´ë“œ ìˆ˜</span>
                                            <select disabled={!isHost} value={roundsOpt} onChange={e => handleUpdateSettings('rounds', e.target.value)} className="bg-black/30 border border-white/10 rounded px-2 py-1 text-white text-xs w-16">
                                                {[1,2,3,4,5,6].map(t => <option key={t} value={t}>{t}R</option>)}
                                            </select></div>
                                        )}
                                        
                                        <div className="flex flex-col"><span className="text-[10px] text-gray-400 font-bold mb-1">í„´ ì‹œê°„</span>
                                        <select disabled={!isHost} value={turnTimeOpt} onChange={e => handleUpdateSettings('turn', e.target.value)} className="bg-black/30 border border-white/10 rounded px-2 py-1 text-white text-xs w-16">
                                            {[20,30,40,50,60].map(t => <option key={t} value={t}>{t}ì´ˆ</option>)}
                                        </select></div>
                                        <div className="flex flex-col"><span className="text-[10px] text-gray-400 font-bold mb-1">ìµœëŒ€ ì¸ì›</span>
                                        <select disabled={!isHost} value={maxPlayersOpt} onChange={e => handleUpdateSettings('max', e.target.value)} className="bg-black/30 border border-white/10 rounded px-2 py-1 text-white text-xs w-16">
                                            {[3,4,5,6,7,8,9,10,11,12].map(t => <option key={t} value={t}>{t}ëª…</option>)}
                                        </select></div>
                                    </div>
                                    <div className="text-xs text-gray-400 font-bold mb-2">ì°¸ì—¬ì ({players.length}/{roomData.settings?.maxPlayers || 12})</div>
                                    <div className="grid grid-cols-3 gap-2 mb-4">
                                        {players.map(p => (
                                            <div key={p.uid} className="bg-white/5 p-2 rounded-lg text-center text-xs font-bold text-gray-300 border border-white/5">
                                                {p.uid === roomData.hostId && <span className="text-yellow-400 mr-1">ğŸ‘‘</span>}{p.name}
                                            </div>
                                        ))}
                                    </div>
                                    {isHost && players.length >= 3 && <button onClick={handleStartGame} className="w-full bg-green-600 py-3 rounded-lg font-bold text-white shadow-lg animate-pulse">ê²Œì„ ì‹œì‘</button>}
                                    {isHost && players.length < 3 && <div className="text-center text-xs text-gray-500">3ëª… ì´ìƒ í•„ìš”</div>}
                                    {!isHost && <div className="text-center text-xs text-gray-500 animate-pulse">ë°©ì¥ì´ ê²Œì„ì„ ì‹œì‘í•˜ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</div>}
                                </div>
                            )}

                            {isPlaying && gameState && (
                                <div className="glass-card p-2 rounded-xl mb-2 shrink-0">
                                    {currentMode === 'spyfall' ? (
                                        <TimerBar startTime={gameState.gameStartTime} duration={roomData.settings.gameDuration} onExpire={handleGameTimeExpire} label="ì „ì²´ ì‹œê°„" colorClass="bg-indigo-500" showControl={isHost} onReduce={handleReduceGameTime} />
                                    ) : (
                                        <div className="flex justify-between items-center text-xs font-bold text-gray-400 mb-2 px-1">
                                            <span>ROUND {gameState.currentRound} / {roomData.settings.rounds}</span>
                                            <span>ì§„í–‰ì¤‘...</span>
                                        </div>
                                    )}
                                    <div className="mt-1 pt-1 border-t border-white/10 flex items-center gap-2">
                                        <div className="flex-1"><TimerBar startTime={gameState.turnStartTime} duration={roomData.settings.turnDuration} onExpire={handleTurnTimeExpire} label="í„´ ì‹œê°„" colorClass="bg-orange-500" /></div>
                                        {isHost && <button onClick={handleSkipTurn} className="bg-white/10 px-2 py-1 rounded text-[10px] text-gray-300">ìŠ¤í‚µ</button>}
                                    </div>
                                </div>
                            )}

                            {isPlaying && (
                                <div className="grid grid-cols-3 gap-2 mb-2 shrink-0">
                                    {players.map(p => {
                                        const isTurn = gameState.turnPlayer === p.uid && !gameState.targetPlayer;
                                        const isTarget = gameState.targetPlayer === p.uid;
                                        const canSelect = currentMode === 'spyfall' && isMyTurnToAsk && messages.some(m => m.uid === userId && m.type === 'question' && m.timestamp > gameState.turnStartTime) && p.uid !== userId;
                                        const isLiarSpeaker = currentMode === 'liar' && gameState.turnPlayer === p.uid;

                                        return (
                                            <div key={p.uid} onClick={() => canSelect && handleSelectPlayer(p.uid)} className={`p-2 rounded-lg text-center relative border transition-all ${isTurn || isLiarSpeaker ? 'bg-blue-900/40 border-blue-500 shadow-lg' : isTarget ? 'bg-orange-900/40 border-orange-500 shadow-lg' : canSelect ? 'bg-white/10 border-white/30 cursor-pointer animate-pulse' : 'bg-black/20 border-white/5'}`}>
                                                <div className="text-xs font-bold truncate text-gray-300 flex items-center justify-center gap-1">{p.uid === roomData.hostId && <span className="text-yellow-400 text-[10px]">ğŸ‘‘</span>}{p.name}{p.uid === userId && <span className="text-[10px] text-gray-500 ml-1">(ë‚˜)</span>}</div>
                                                {(isTurn || isLiarSpeaker) && <div className="text-[10px] text-blue-300 font-bold mt-1">{currentMode === 'liar' ? 'ë°œì–¸ ì¤‘' : 'ì§ˆë¬¸ ì¤‘'}</div>}
                                                {isTarget && <div className="text-[10px] text-orange-300 font-bold mt-1">ë‹µë³€ ì¤‘</div>}
                                                {canSelect && <div className="text-[10px] text-white font-bold mt-1">ğŸ‘† ì§€ëª©</div>}
                                            </div>
                                        )
                                    })}
                                </div>
                            )}

                            <div className="flex-1 min-h-0 mb-2 overflow-hidden flex flex-col">
                                <ChatArea messages={messages} chatInput={chatInput} setChatInput={setChatInput} sendMessage={sendMessage} myNickname={nickname} placeholderText={placeholderText} />
                            </div>

                            {isPlaying && (
                                <div className="flex gap-2 shrink-0 mb-safe">
                                    <button onClick={() => setShowRoleModal(true)} className="flex-1 bg-white/5 py-3 rounded-xl text-sm font-bold border border-white/10">ë‚´ ì—­í• </button>
                                    
                                    {/* ğŸ”¥ ì‹œê°„ ë‹¨ì¶• íˆ¬í‘œ ë²„íŠ¼ */}
                                    <button onClick={handleTimeReductionToggle} 
                                        className={`flex-1 py-3 rounded-xl text-sm font-bold border transition-colors ${hasVotedTime ? 'bg-blue-600 border-blue-400 text-white' : 'bg-blue-900/30 border-blue-500/30 text-blue-300'}`}>
                                        â±ï¸ ì‹œê°„ ë‹¨ì¶• {timeVotes}/{Math.ceil(players.length/2)}
                                    </button>

                                    {currentMode === 'liar' && isMyLiarTurn && (
                                        <button onClick={handleLiarPassTurn} className="flex-1 bg-green-600 text-white py-3 rounded-xl text-sm font-bold shadow-lg animate-pulse">ë°œì–¸ ì¢…ë£Œ</button>
                                    )}
                                </div>
                            )}

                            {showToast && <Toast message="ë°© ì½”ë“œê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!" />}

                            {pendingAnswer && (
                                <AnswerConfirmModal 
                                    text={pendingAnswer} 
                                    onConfirm={confirmAnswer} 
                                    onCancel={() => setPendingAnswer(null)} 
                                />
                            )}

                            {showRoleModal && me && (
                                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/90 p-6 modal-enter" onClick={() => setShowRoleModal(false)}>
                                    <div className={`w-full max-w-sm p-6 rounded-3xl text-center border-2 ${me.isSpy ? 'bg-red-950 border-red-500' : 'bg-slate-900 border-blue-500'}`} onClick={e => e.stopPropagation()}>
                                        <div className="text-5xl mb-4">{me.isSpy ? (currentMode === 'liar' ? 'ğŸ¤¥' : 'ğŸ•µï¸') : 'ğŸ“'}</div>
                                        <h2 className="text-2xl font-black text-white mb-2">{me.isSpy ? (currentMode === 'liar' ? 'ë‹¹ì‹ ì€ ë¼ì´ì–´!' : 'ë‹¹ì‹ ì€ ìŠ¤íŒŒì´!') : (currentMode === 'liar' ? 'ì œì‹œì–´ í™•ì¸' : 'ì¥ì†Œ í™•ì¸')}</h2>
                                        {!me.isSpy && <div className="text-2xl font-bold text-yellow-400 mb-1">{roomData.locationName}</div>}
                                        <div className="text-sm text-gray-300">{currentMode === 'liar' && !me.isSpy ? 'ë¼ì´ì–´ì—ê²Œ ì œì‹œì–´ë¥¼ ë“¤í‚¤ì§€ ë§ˆì„¸ìš”!' : me.role}</div>
                                        <button onClick={() => setShowRoleModal(false)} className="mt-6 w-full bg-white/10 py-3 rounded-xl font-bold">í™•ì¸</button>
                                    </div>
                                </div>
                            )}
                            
                            {showLocationModal && <CheatSheetModal onClose={() => setShowLocationModal(false)} mode={currentMode} />}
                            {showRuleModal && <RuleModal onClose={() => setShowRuleModal(false)} mode={currentMode} />}
                            
                            {isMyTurnToAsk && messages.some(m => m.uid === userId && m.type === 'question' && m.timestamp > gameState.turnStartTime) && (
                                <PlayerSelectionModal players={players.filter(p => p.uid !== userId)} onSelect={handleSelectPlayer} />
                            )}
                            
                            {(isVoting || showVoteModal) && <VoteModal players={players} votes={roomData.votes} myVote={(roomData.votes || {})[userId]} onVote={handleVote} onClose={() => setShowVoteModal(false)} mode={currentMode} />}
                            
                            {turnNotification && (
                                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 p-6 modal-enter" onClick={() => setTurnNotification(null)}>
                                    <div className={`w-full max-w-sm p-6 rounded-3xl text-center border-4 ${turnNotification.color} bg-gray-900`}>
                                        <div className="text-4xl mb-3 animate-bounce">{turnNotification.type === 'ask' ? 'ğŸ—£ï¸' : 'ğŸ’¬'}</div>
                                        <h2 className="text-2xl font-black text-white">{turnNotification.title}</h2>
                                        <p className="text-gray-300 mt-2">{turnNotification.message}</p>
                                    </div>
                                </div>
                            )}

                            {roomData.status === 'finished' && (
                                <div className="fixed inset-0 z-[90] flex items-center justify-center bg-black/90 p-6 modal-enter">
                                    <div className="glass-card w-full max-w-md rounded-3xl p-6 text-center">
                                        <h2 className="text-3xl font-black text-yellow-400 mb-2">GAME OVER</h2>
                                        <p className="text-white/60 mb-4">{roomData.endReason}</p>
                                        <div className="bg-white/10 rounded-xl p-3 mb-4"><div className="text-xs text-gray-400">{currentMode === 'liar' ? 'ì •ë‹µ ì œì‹œì–´' : 'ì •ë‹µ ì¥ì†Œ'}</div><div className="text-2xl font-bold text-white">{roomData.locationName}</div></div>
                                        <div className="flex gap-2">
                                            <button onClick={() => { setView('lobby'); setRoomId(''); }} className="flex-1 bg-gray-600 py-3 rounded-xl font-bold">ë‚˜ê°€ê¸°</button>
                                            {isHost && <button onClick={handleRestart} className="flex-1 bg-green-600 py-3 rounded-xl font-bold">ë‹¤ì‹œ í•˜ê¸°</button>}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                        <SideCheatSheet isLeft={false} mode={currentMode} />
                    </div>
                );
            }
            return null;
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ErrorBoundary><App /></ErrorBoundary>);
    </script>
</body>
</html>